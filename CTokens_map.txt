\ 
CT
// X
/* X
\ 
DELIMITER
{ L_CURLY
} R_CURLY
( L_PAREN
) R_PAREN
[ L_SQUARE
] R_SQUARE
; SEMI
, COMMA
: COLON
:: SCOPE_RESOLUTION
. DOT
... ELLIPSIS
# HASH
## HASH_HASH
@ AT_SYMBOL
\ 
PREPROCESSORS
#include INCLUDE_HEADER
#define DEFINE_MACRO
#undef UNDEFINE_MACRO
#if IF_CONDITIONAL
#ifdef IF_DEFINED
#ifndef IF_NOT_DEFINED
#elif  ELIF_CONDITIONAL
#elifdef ELIFDEF_CONDITIONAL
#elifndef ELIFNDEF_CONDITIONAL
#else ELSE_CONDITIONAL
#endif END_IF_CONDITIONAL
#error ERROR_DIRECTIVE
#warning WARNING_DIRECTIVE
#pragma PRAGMA_DIRECTIVE
#line LINE_DIRECTIVE
#embed EMBED_DIRECTIVE
\ 
KEYWORD
auto AUTO
break BREAK
case CASE
char CHAR
const CONST
continue CONTINUE
default DEFAULT
do DO
double DOUBLE
else ELSE
enum ENUM
extern EXTERN
float FLOAT
for FOR
_Alignof ALIGNOF
_Atomic ATOMIC
goto GOTO
if IF
inline INLINE
int INT
long LONG
register REGISTER
restrict RESTRICT
return RETURN
short SHORT
signed SIGNED
sizeof SIZEOF
static STATIC
struct STRUCT
switch SWITCH
while WHILE
_Alignas ALIGNAS
typedef TYPEDEF
union UNION
unsigned UNSIGNED
void VOID
volatile VOLATILE
_Bool BOOL
_Complex COMPLEX
_Generic GENERIC
_Imaginary IMAGINARY
_Noreturn NORETURN
_Static_assert STATIC_ASSERT
_Thread_local THREAD_LOCAL
\ 
OPERATOR
+ ADD
- SUB
* MUL
/ DIV
% MOD
++ INR
-- DCR
== EQUAL
!= NOT_EQUAL
> GREATER
< LESS
>= GREATER_EQUAL
<= LESS_EQUAL
&& LOGICAL_AND
|| LOGICAL_OR
! LOGICAL_NOT
& BIT_AND
| BIT_OR
^ BIT_XOR
~ BIT_NOT
<< BIT_LEFT_SHIFT
>> BIT_RIGHT_SHIFT
+= ADD_ASSIGN
-= SUB_ASSIGN
*= MUL_ASSIGN
/= DIV_ASSIGN
%= MOD_ASSIGN
&= BITWISE_AND_ASSIGN
|= BIT_OR_ASSIGN
^= BIT_XOR_ASSIGN
<<= LEFT_SHIFT_ASSIGN
>>= RIGHT_SHIFT_ASSIGN
= ASSIGN
? TERNARY_CONDITIONAL
: TERNARY_SEPARATOR
-> ARROW
\